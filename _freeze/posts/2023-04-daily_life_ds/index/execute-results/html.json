{
  "hash": "1be281566d7cf7e2c440e126d4170408",
  "result": {
    "markdown": "---\ntitle: \"Data Detective Chronicles: Solving the Puzzles of Daily Data Science\"\nauthor: \"I. Muliterno\"\ndate: \"2023-04-18\" \ncategories: \n# exemplo de categorias:\n  - \"Data Science\"\n  - \"R\"\n  - \"DDC\"\n  - \"merge\"\n  - \"join\"\nimage: \"DDC.PNG\"  \ntoc: true # isso habilita o sumário ao lado do post\n#image: \"images/logo.png\" # imagem usada na página inicial junto ao post\n#bibliography: \"pacotes.bib\" # arquivo de bibliografia. Pode adicionar mais arquivos!\ndraft: false # enquanto estiver draft: true, o post é um rascunho\nknitr: \n  opts_chunk: \n    message: true\n    warning: false\n    echo: true\n    fig.align: 'center'\nhtml:\n  code-fold: true\n---\n\n\nWelcome to the first instalment of my new blog series Data Detective Chronicles (DDC). In this series, we'll explore various daily challenges data scientists face and share practical solutions to overcome them. Today, we'll dive into a common data joining problem that can be both perplexing and frustrating: joining two datasets without a proper key column. We'll walk you through a real-life scenario and demonstrate how to tackle this issue using R.\n\n### The Challenge: Joining Two Datasets Without a Proper Key Column\n\nImagine you have been given two datasets, table1 and table2, that you need to join for further analysis. Unfortunately, the datasets do not have a proper key column to join on, but they do have two columns with similar information: 'customer_desc' in table1 and 'client_desc' in table2. The catch is that the entries in these columns have slight differences, such as \"PRETTY COMMERCE LTDA\" in table1 and \"PRETTY COM LTDA\" in table2. Your task is to find the best way to join these datasets while accounting for these discrepancies.\n\n### Solution: Using String Similarity Measures\n\nIn situations like this, one possible solution is to use string similarity measures to join the datasets. A popular measure for string similarity is the Jaro-Winkler distance, which can be easily calculated using the 'stringdist' package in R. Here's a step-by-step guide on how to approach this challenge:\n\n1.  Install and load the necessary packages:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(stringdist)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.4\n✔ ggplot2   3.4.1     ✔ stringr   1.5.0\n✔ lubridate 1.9.2     ✔ tibble    3.1.8\n✔ purrr     1.0.1     ✔ tidyr     1.3.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract() masks stringdist::extract()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(kableExtra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n```\n:::\n\n```{.r .cell-code}\nlibrary(knitr)\n```\n:::\n\n\n2.  Create a function to calculate the Jaro-Winkler similarity:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njw_similarity <- function(a, b) {\n  return(1 - stringdist(a, b, method = \"jw\"))\n}\n```\n:::\n\n\n3.  Perform a cartesian join (cross join) between the two datasets, note I use the variable $key = 1$ to make sure I get all possible combinations between *customer_desc* and *client_desc*, the so called cross join:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable1 <- data.frame(customer_desc = c(\"PRETTY COMMERCE LTDA\", \"ANOTHER COMPANY\",\"CORNER SHOP\"))\ntable2 <- data.frame(client_desc = c(\"PRETTY COM LTDA\", \"DIFFERENT COMPANY\",\"CORNER S LTDA\"))\n\ncross_join <- table1 %>%\n  mutate(key = 1) %>%\n  full_join(table2 %>% mutate(key = 1), by = \"key\") %>%\n  select(-key)\n\ncross_join %>%\n  kable(\"html\", caption = \"Cross Join Table\", align = \"c\") %>%\n  kable_styling(\"striped\", full_width = F) %>%\n  column_spec(1, bold = T, color = \"grey\") %>%\n  column_spec(2, bold = T, color = \"red\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Cross Join Table</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> customer_desc </th>\n   <th style=\"text-align:center;\"> client_desc </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> PRETTY COMMERCE LTDA </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> PRETTY COM LTDA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> PRETTY COMMERCE LTDA </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> DIFFERENT COMPANY </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> PRETTY COMMERCE LTDA </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> CORNER S LTDA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> ANOTHER COMPANY </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> PRETTY COM LTDA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> ANOTHER COMPANY </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> DIFFERENT COMPANY </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> ANOTHER COMPANY </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> CORNER S LTDA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> CORNER SHOP </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> PRETTY COM LTDA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> CORNER SHOP </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> DIFFERENT COMPANY </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;color: grey !important;\"> CORNER SHOP </td>\n   <td style=\"text-align:center;font-weight: bold;color: red !important;\"> CORNER S LTDA </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n4.  Calculate the Jaro-Winkler similarity between 'customer_desc' and 'client_desc' columns:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncross_join <- cross_join %>%\n  mutate(similarity = mapply(jw_similarity, customer_desc, client_desc))\n```\n:::\n\n\n5.  Filter the best matches based on a similarity threshold or the highest similarity value:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nthreshold <- 0.78\n\nmatched_data <- cross_join %>%\n  filter(similarity >= threshold) %>%\n  group_by(customer_desc) %>%\n  top_n(1, wt = similarity) %>%\n  ungroup()\n\nmatched_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  customer_desc        client_desc     similarity\n  <chr>                <chr>                <dbl>\n1 PRETTY COMMERCE LTDA PRETTY COM LTDA      0.917\n2 CORNER SHOP          CORNER S LTDA        0.781\n```\n:::\n:::\n\n\nIn this example, we've successfully joined the two datasets based on the Jaro-Winkler similarity between the 'customer_desc' and 'client_desc' columns. Keep in mind that the similarity threshold may need to be adjusted depending on your specific use case.\n\n## Conclusion\n\nJoining datasets without a proper key column can be a challenging task for data scientists. However, by using string similarity measures like the Jaro-Winkler distance, you can tackle this issue and find the best matches between columns with slight discrepancies. Stay tuned for the next instalment of our series, where we will continue to explore the daily challenges faced by data scientists and share\n\nSee ya!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}