{
  "hash": "4245647803abced8e54de863063443c6",
  "result": {
    "markdown": "---\ntitle: \"DDC: Tackling Missing or Inconsistent Data\"\nauthor: \"I. Muliterno\"\ndate: \"2023-04-18\" \ncategories: \n# exemplo de categorias:\n  - \"Data Science\"\n  - \"R\"\n  - \"DDC\"\n  - \"missing\"\n  - \"inconsistent\"\nimage: \"DDC.PNG\"  \ntoc: true # isso habilita o sumário ao lado do post\n#image: \"images/logo.png\" # imagem usada na página inicial junto ao post\n#bibliography: \"pacotes.bib\" # arquivo de bibliografia. Pode adicionar mais arquivos!\ndraft: false # enquanto estiver draft: true, o post é um rascunho\nknitr: \n  opts_chunk: \n    message: true\n    warning: false\n    echo: true\n    fig.align: 'center'\nhtml:\n  code-fold: true\n---\n\n\nIn the world of data science, dealing with missing or inconsistent data is an everyday challenge. The quality of your insights, predictions, and models heavily depends on the quality of the data you use. In this second post of our series on data science daily life challenges, we'll explore various strategies for handling missing or inconsistent data using R, and how to make informed decisions about the best approach for your specific situation.\n\n1.  Understand the nature of the missing or inconsistent data\n\nBefore diving into any solutions, it's essential to understand the nature of the missing or inconsistent data you're dealing with. In R, you can use the **`summary()`** function to get an overview of your dataset, including the number of missing values:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(stringdist)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.4\n✔ ggplot2   3.4.1     ✔ stringr   1.5.0\n✔ lubridate 1.9.2     ✔ tibble    3.1.8\n✔ purrr     1.0.1     ✔ tidyr     1.3.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract() masks stringdist::extract()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(mice)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'mice'\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n```\n:::\n\n```{.r .cell-code}\nlibrary(DMwR2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n```\n:::\n\n```{.r .cell-code}\ndataset <- data.frame(col1 = c(1:3, NA),\n                 col2 = c(\"one\", NA,\"cool\", \"text\"), \n                 col3 = c(TRUE, FALSE, TRUE, TRUE), \n                 col4 = c(0.5, 4.7, 3.2, NA),\n                 date_column = c(\"2000/1/1\",\"2000/2/1\" ,\"2000/3/1\" ,\"2023/13/40\"),                 stringsAsFactors = FALSE)\n\nsummary(dataset)\n```\n:::\n\n\n2.  Data Imputation\n\nOne common approach for dealing with missing data is imputation. Imputation involves estimating the missing values based on other available data. Some popular imputation methods in R include:\n\n-   Mean, median, or mode imputation: Replace missing values with the mean, median, or mode of the column.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndataset <- dataset %>%\n  mutate(col4 = if_else(is.na(col4), mean(col4, na.rm = TRUE), col4))\n```\n:::\n\n\n-   Linear regression imputation: Use a linear regression model to estimate missing values based on other variables in the dataset.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nimputed_data <- mice(dataset, method = 'norm.predict', m = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n iter imp variable\n  1   1  col1\n  1   2  col1\n  1   3  col1\n  1   4  col1\n  1   5  col1\n  2   1  col1\n  2   2  col1\n  2   3  col1\n  2   4  col1\n  2   5  col1\n  3   1  col1\n  3   2  col1\n  3   3  col1\n  3   4  col1\n  3   5  col1\n  4   1  col1\n  4   2  col1\n  4   3  col1\n  4   4  col1\n  4   5  col1\n  5   1  col1\n  5   2  col1\n  5   3  col1\n  5   4  col1\n  5   5  col1\n```\n:::\n\n```{.r .cell-code}\ncomplete_data <- complete(imputed_data)\n```\n:::\n\n\n-   K-Nearest Neighbours (KNN) imputation: Fill in missing values by averaging the values of the k-nearest neighbours. I will give an example of the code below, but you need a bigger dataset for that approach, that's why the code is commented.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#imputed_data <- knnImputation(dataset, k = 5)\n```\n:::\n\n\nIt's important to note that imputation can introduce bias or distort the underlying data distribution, so it should be used with caution.\n\n3.  Removing missing or inconsistent data\n\nIn some cases, it may be appropriate to remove rows or columns containing missing or inconsistent data. This can be done using techniques such as:\n\n-   Listwise deletion: Remove any rows containing missing values.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndataset <- na.omit(dataset)\n```\n:::\n\n\n-   Dropping columns: Remove columns with a high proportion of missing or inconsistent data.\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    column_with_missing_data <- sapply(dataset,function(x)sum(is.na(x)))\n    column_with_missing_data <- column_with_missing_data[column_with_missing_data > 0]\n    \n    dataset <- dataset %>% select(-column_with_missing_data)\n    dataset\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      col1 col2 col3 col4 date_column\n    1    1  one TRUE  0.5    2000/1/1\n    3    3 cool TRUE  3.2    2000/3/1\n    ```\n    :::\n    :::\n\n\n    Keep in mind that removing data can lead to loss of information and may introduce bias if the data is not missing at random.\n\n    4.  Data Standardisation and Transformation\n\n    Inconsistent data often results from variations in data entry, formats, or units. To address this issue, you can standardise and transform the data using R functions like:\n\n    -   Establishing consistent formats for dates ( in case it is of type character and there's inconsistences like \"13/40/2023\" the return would be NA, so it will help you to recognise inconsistences.\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    dataset$date_column <- as.Date(dataset$date_column, format = \"%Y/%m/%d\")\n    dataset\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      col1 col2 col3 col4 date_column\n    1    1  one TRUE  0.5  2000-01-01\n    3    3 cool TRUE  3.2  2000-03-01\n    ```\n    :::\n    :::\n\n\n    Dealing with missing or inconsistent data is a common challenge for data scientists, but it's also an opportunity to refine your skills and improve your dataset's quality. By using R to understand the nature of the missing or inconsistent data and applying appropriate strategies, you can make more informed decisions and produce more accurate and reliable insights. In the next post of our series on data science daily life challenges, we'll explore the intricacies of handling high-dimensional data and the techniques used to simplify analyses using R. Stay tuned!\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}